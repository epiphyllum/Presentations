<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Don't Blow Your Stack</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/pojoaque.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Don't Blow Your Stack</h1>
					<h2>Recursive Functions for Everyone</h2>
					<p>
						<small><a href="https://twitter.com/OweinReese">@OweinReese</a></small>
					</p>
					<aside class="notes">
						<ol>
							<li></li>
						</ol>
					</aside>
				</section>
				<section>
					<h2>stuff</h2>
					<p>--</p>
					<ol>
						<li>Come up with an example imperative to convert</li>
						<li>Come up with an example imperative using Futures
							<ol>
								<li>Ok, come up with DB thing where the exceptions matter and/or a version field needs to matter so "count" could be 0.</li>
								<li>That is, just working off Failure isn't enough</li>
							</ol>
						</li>
						<li></li>
					</ol>
				</section>
				<section>
					<h2>Naive Tree Traversal</h2>
					<pre><code class="scala hljs">
trait Tree
case class Node(left: Tree, right: Tree) extends Tree
case class Empty extends Tree
					</code></pre>
					<aside class="notes">
						<ol>
							<li>No loops</li>
							<li>non-empty, i.e. at least 1 Node</li>
						</ol>
					</aside>
				</section>
				<section>
					<h2>Imperative</h2>
					<pre><code class="scala hljs">import scala.collections.mutable.{ Map => MMap }

def longest(tree: Tree): Int ={
  val search = MMap(0 -> tree)
  var longest = 0
  while(search.nonEmpty){
    val current = search.head //can't use an iterator
    current match{
      case (v, Node(Empty, Empty)) => longest = Math.max(longest, v)
      case (v, Node(left, Empty)) => search += (v+1, left)
      case (v, Node(Empty, right)) => search += (v+1, right)
      case (v, Node(left, right)) => search ++= MMap(v+1 -> left, v+1 -> right)
    }
    search -= current
  }
  longest
}
					</code></pre>
					<aside class="notes">
						<ol>
							<li>Max comparison made only at leaves</li>
							<li>Half of code is state management</li>
						</ol>
					</aside>
				</section>
				<section>
					<h2>Recursive</h2>
					<pre><code class="scala hljs">
def longest(tree: tree): Int = tree match{
  case Node(Empty, Empty) => 0
  case Node(left, Empty) => 1 + longest(left)
  case Node(Empty, right) => 1 + longest(right)
  case Node(left, right) => 1 + Math.max(longest(left), longest(right))
}
					</code></pre>
					<aside class="notes">
						<ol>
							<li>There is no state to manage</li>
							<li>5 vs 13 SLOC</li>
							<li>Max comparison made every loop.</li>
						</ol>
					</aside>
				</section>
				<section>
					<section>
						<h2>Tail Recursion</h2>
						<pre><code class="scala hljs">
def longest(rem: List[(Int, Tree)], value: Int = 0): Int = 
  rem match{
    case Nil => value
    case (v, Node(Empty, Empty)) :: t => longest(t, Math.max(v, value))
    case (v, Node(left, Empty)) :: t => longest((v+1, left) :: t, value)
    case (v, Node(Empty, right)) :: t => longest((v+1, right) :: t, value)
    case (v, Node(left, right)) :: t => longest((v+1, left) :: (v+1, right) :: t, value)
  }
						</code></pre>
						<aside class="notes">
							<ol>
								<li>Only need to check condition at leaves.</li>
							</ol>
						</aside>
					</section>
					<section>
						<h2>Tail Recursive Pattern</h2>
						<pre><code class="python hljs">
def function(args) = 
  if(predicate(args)) value(args)
  else function('args')
						</code></pre>
						<div class="fragment">
							<pre><code class="python hljs">
def function(args)(state) = 
  if(predicate(state)) value(state)
  else function(args)('state')
						</code></pre>
						</div>
					</section>
					<section>
						<h2>Scalac Compiler</h2>
						<pre><code class="python hljs">
def function(args)(state) ={
  state0 = state
  labelName:
    if(predicate(state0)) value(state0)
    else{
      state0 = 'state'
      goto labelName
    }
}
						</code></pre>
					</section>
				</section>
				<section>
					<h2>Converting Imperative</h2>
				</section>
				<section>
					<section>
						<h2>Building On Futures</h2>
						<pre><code class="scala hljs">
def retry[A](f: => Future[A], times: Int = 1): Future[A] ={
  var value = f
  var counter = 0
  while(counter != times){
    value = value.recoverWith{ case _ => f }
    counter += 1
  }
  value
}
						</code></pre>
					</section>
					<section>
						<h2>Recursively</h2>
						<pre><code class="scala hljs">
def retry[A](f: => Future[A], times: Int = 1): Future[A] ={
  if(times < 1) f 
  else f.recoverWith{ case _ => retry(f, times-1) }
}
						</code></pre>
					</section>
					<section>
						<h2>Tail Recursively</h2>
						<pre><code class="scala hljs">
}
def retry[A](f: => Future[A], times: Int = 1): Future[A] ={
  def redo(fut: Future[A], rem: Int): Future[A] ={
    if(rem < 1) fut
    else redo(fut.recoverWith{ case _ => f }, rem-1)
  }
  redo(f, times)
}
						</code></pre>
					</section>
				</section>
				<section>
					<h2>Mutual Tail Recursion</h2>
					<pre><code class="scala hljs">
case class Game(deck: List[Card], top: Card, pile: List[Card])

object BestMove extends GameStragey{
  def next(game: Game, player: List[Card]): (Game, List[Card]) ={
  	if(canMove(game.top, player)) makeMove(game, player)
  	else drawCard(game, player)
  }

  def drawCard(game: Game, player: List[Card]): (Game, List[Card]) = 
    deck match {
      case head :: tail => next(Game(tail, top, pile), head :: player)
      case Nil => drawCard(Game(shuffle(pile), top, Nil), player)
    }
  //rest of code...
}
					</code></pre>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			Reveal.initialize({
				history: true,
				minScale: 0.7,
				maxScale: 1.0,

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/notes-server/client.js', async: true }
				]
			});
		</script>
	</body>
</html>
